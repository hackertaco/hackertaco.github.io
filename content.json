{"meta":{"title":"0년차 개발자의 블로그","subtitle":"happy hacking중!","description":"","author":"hackertaco","url":"https://hackertaco.github.io","root":"/"},"pages":[],"posts":[{"title":"ec2 슈퍼심플 도커 배포법","slug":"ec2-슈퍼심플-도커-배포법","date":"2021-01-23T14:18:35.000Z","updated":"2021-01-24T14:43:09.880Z","comments":true,"path":"2021/01/23/ec2-슈퍼심플-도커-배포법/","link":"","permalink":"https://hackertaco.github.io/2021/01/23/ec2-%EC%8A%88%ED%8D%BC%EC%8B%AC%ED%94%8C-%EB%8F%84%EC%BB%A4-%EB%B0%B0%ED%8F%AC%EB%B2%95/","excerpt":"","text":"여러명이서 함께하던 내 프로젝트 서버가 죽었다.이제 모두들 이 프로젝트에 대한 애정도 딱히 없고, 굳이 이 서비스를 유지할 이유도 없어 죽도록 놔둔 것이지만, 난 내 개인적으로 첫번째 프로젝트였던지라 감회가 달랐다. 그리고 기획부터 개발까지 으쌰으쌰 달려왔기에, 더욱 더 의미가 깊었다. 따라서, 혼자, 서버를, 살려보기로 했다! 해야할 일 프론트 서버도 죽고 서버도 죽고 도메인도 계약기간이 만료됐다. 따라서 이 세가지를 모두 renew해야한다. 도메인부터 등록하자.원래는 가비아에서 도메인을 등록했었는데, 그냥 편의상 aws로 도메인을 구입하기로 했다. 도메인이름도 바꿨다. 11$가 나오면 대충 14$가 나온다.","categories":[],"tags":[]},{"title":"자료구조 9 binary search tree","slug":"자료구조-9-binary-search-tree","date":"2021-01-17T16:24:04.000Z","updated":"2021-01-23T14:17:07.139Z","comments":true,"path":"2021/01/18/자료구조-9-binary-search-tree/","link":"","permalink":"https://hackertaco.github.io/2021/01/18/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-9-binary-search-tree/","excerpt":"","text":"일전에 binary tree 구조를 다룬 적이 있다.이름도 비슷한 binary search tree는, 각 노드가 root에서부터 leaf까지 정렬이 되어있는 구조다. 이 bst는, (줄여 말하겠음) 이진 탐색과 연결 리스트를 결합한 구조로, 이진탐색의 효율적인 탐색 능력을 유지하고, 연결리스트의 장점인 삽입과 삭제가 빠르게 진행되도록 한다.힙이랑 비슷한듯 한데, 힙은 자식노드보다 부모 노드가 무조건 크거나(최대힙) 무조건 작은(최소힙) 특징을 가지고 있으나, bst의 경우는 왼쪽 자식이 제일 작고, 부모가 그 다음으로 크고, 오른쪽 자식이 제일 큰.. 다소 신기한 구조를 가지고 있다. 따라서, 힙은 우선순위 정렬에, bst는 탐색에 강점이 있다고들 합니다. 이진 탐색 use case 데이터 검색 부수적인 알고리즘이나 자료구조 생성 이진 탐색의 구현1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//1. node 선언class Node &#123; constructor(value) &#123; this.value = value; this.left = null; this.right = null; &#125;&#125;class BinarySearchTree &#123; constructor() &#123; this.root = null; &#125; //2. insert insert(value) &#123; let newNode = new Node(value); if (this.root === null) &#123; this.root = newNode; &#125; let current = this.root; while (current) &#123; if (value === current.value) return undefined; if (value &lt; current.value) &#123; if (current.left === null) &#123; current.left = newNode; &#125; current = current.left; &#125; else &#123; if (current.right === null) &#123; current.right = newNode; &#125; current = current.right; &#125; &#125; &#125; find(value) &#123; if (!root) return false; let current = this.root; let found = false; while (current &amp;&amp; !found) &#123; if (value &lt; current.value) &#123; current = current.left; &#125; else if (value &gt; current.value) &#123; current = current.right; &#125; else &#123; found = current; &#125; &#125; return found; &#125;&#125;","categories":[],"tags":[]},{"title":"자료구조 8 heap","slug":"자료구조-8-heap","date":"2021-01-16T14:40:46.000Z","updated":"2021-01-17T16:22:29.961Z","comments":true,"path":"2021/01/16/자료구조-8-heap/","link":"","permalink":"https://hackertaco.github.io/2021/01/16/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-8-heap/","excerpt":"","text":"완전 이진 트리의 일종.이 완전 이진 트리란, 이전에 했던 binary tree 중에서도 마지막 레벨의 leaf들이 모두 채워져 있거나, 혹은 왼쪽만 채워져 있는 것을 말한다.우선순위 큐란, 큐 자료구조 중에서도 우선순위가 있어 데이터가 우선순위를 기준으로 빠져나간다는 자료구조. 힙에서는 가장 높은(혹은 가장 낮은) 우선순위를 가지는 노드가 항상 뿌리노드에 오게 되는 특징이 있으며, 이를 응용하면 우선순위 큐와 같은 추상적 자료형을 구현할 수 있다. 힙의 특징 여러 값들 중 최댓값과 최솟값을 쉬이 찾아낼 수 있는 구조 반정렬 상태를 유지한다.","categories":[],"tags":[]},{"title":"자료구조 7 수식트리와 우선순위 큐","slug":"자료구조-7-수식트리와-우선순위-큐","date":"2021-01-09T14:00:26.000Z","updated":"2021-01-17T14:52:09.244Z","comments":true,"path":"2021/01/09/자료구조-7-수식트리와-우선순위-큐/","link":"","permalink":"https://hackertaco.github.io/2021/01/09/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-7-%EC%88%98%EC%8B%9D%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90/","excerpt":"","text":"수식 트리? 수식트리는 이진트리의 한 종류로, 수식 또한 트리 형식으로 만들어놓은 것.root가 중간에 들어가는 중위표기법으로 수식을 변화시키는 것이 메인 목적.연산 과정에서 연산자의 우선순위 고려를 할 필요가 없기 때문에, 해석이 쉽다. 다만 중위 표기법의 수식을 바로 트리로 구현하는 것이 쉽지 않아서, 중위 표기법의 수식을 후위 표기법의 수식으로 변환 후, 수식 트리로 변환한다. 우선순위 큐 ? 원래 우리가 알고 있는 큐와 상당히 비슷하지만, 우선순위를 매겨 데이터 삽입과 삭제를 하는 구조!이 구조는 힙 기반, 배열 기반, 연결리스트 기반 등 세가지로 구현해볼 수 있다.우선 순위가 높은 것부터 먼저 빠져나가는 개념! use case of 우선순위 큐! 시뮬레이션 시스템네트워크 트래픽 제어운영 체제에서의 작업 스케쥴링수치 해석적인 계산","categories":[],"tags":[]},{"title":"자료구조 6 binary tree","slug":"자료구조-6-binary-tree","date":"2021-01-06T15:30:54.000Z","updated":"2021-01-08T13:03:57.726Z","comments":true,"path":"2021/01/07/자료구조-6-binary-tree/","link":"","permalink":"https://hackertaco.github.io/2021/01/07/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-6-binary-tree/","excerpt":"","text":"binary tree? binary tree는 root 라고 불리는 제일 꼭대기의 노드가 조상이라 가정하고, 그 조상으로부터 두명의 아이가 항상 태어나는 형태라고 생각하면 된다. 조상은 하나지만,, 끝은 2배씩 늘어난 자식들로 가득하다 ! 한 노드 당 최대 두명의 자식을 가질 수 있는데, 우리는 이를 각각 left와 right라고 부른다. 만일 이들이 자식이 없으면, 최 하단, 이파리라 불린다. Use case?실은 binary tree 자체로 실 사용 케이스에 적용되는 것은 아니라 할 수 있다. 그 까닭은, 만약 이 트리가 랜덤한 순서대로 구성되어 있다면, linked list와 별반 다르지 않는 복잡도를 가지기 때문이다. 따라서, binary tree는 잘 정렬되지 않으면 별 소용이 없다. 다만, 이진 탐색 트리나 heap 등에서 많이 응용되는 자료구조다. Big O insertion: O(1) Deletion: O(n) Search: O(n) 삭제하거나, 노드를 탐색하는 경우 ! 자식을 차례대로 탐색하면서 내려가야 한다. 그 이유는 아무런 sorting이 돼있지 않기 때문.최악의 경우 이파리에 위치하지… 따라서 O(n) Realization binary tree는 종류가 생각보다 다양하다. 모든 부모 노드에 자식이 2개씩 꽉꽉 들어차 있으면 그건 완전 이진트리. 그게 아니고 조금 편향돼있으면 편향 트리… 1234567891011121314151617181920212223242526272829303132333435363738// 1. node class 선언class Node &#123; constructor(data) &#123; this.data = data; this.left = null; this.right = null; &#125;&#125;// 2. tree class 선언class BinaryTree &#123; constructor()&#123; this.root = null; &#125;&#125;// 3. 삽입을 시작하지insert(data)&#123; let newNode = new Node(data); if(this.root === null)&#123; this.root = newNode; &#125; let curr = this.root;traverse(curr)&#125;//4. 사실은 순회부터 먼저 해야 했다.traverse(root)&#123; if(root == null)&#123; return; &#125; traverse(root.left) traverse(root.right)&#125;","categories":[],"tags":[]},{"title":"자료구조 5 deque","slug":"자료구조-5-deque","date":"2021-01-04T14:27:55.000Z","updated":"2021-01-06T15:29:55.973Z","comments":true,"path":"2021/01/04/자료구조-5-deque/","link":"","permalink":"https://hackertaco.github.io/2021/01/04/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-5-deque/","excerpt":"","text":"deque? 큐와 스택을 공부하면서, 큐는 fifo, 스택은 lifo로 데이터들이 움직이는 것을 보았다.그런데, deque는 앞에도 뒤에서도 데이터가 들어오고 빠져나갈 수 있다고 한다. possible operations? add front add back remove front remove back select front select back size is empty clear use case? 최근의 케이스는 undo, history 등에서 많이 쓰인다고. 조금 더 과정이 덜한 큐나 스택을 만드는 데 의의가 있지 않을까. realize deque 클래스 만들기 1234567class deque &#123; constructor() &#123; this.items = &#123;&#125;; this.size = 0; this.smallSize = 0; &#125;&#125; add front 1234addBack(data)&#123; this.items[this.size] = data this.size ++&#125; add back 1234567891011121314addFront(data)&#123; if(this.isEmpty() === 0)&#123; addBack(data) &#125;else if (this.smallSize &gt; 0)&#123; this.smallSize--; this.items[this.smallSize] = data; &#125;else&#123; for(let i = this.size; i &gt; 0; i--)&#123; this.items[this.size] = this.items[this.size - 1] &#125; this.size++ this.items[0] = data; &#125;&#125; remove front 12345678910removeFront()&#123; if(this.isEmpty() === 0)&#123; return; &#125; let result = this.items[this.smallSize]; delete this.items[this.smallSize]; this.smallSize++;&#125; remove back 123456789removeBack()&#123; if(this.isEmpty() === 0)&#123; return; &#125; let result = this.items[this.size - 1]; delete this.items[this.size - 1]; this.size--;&#125; is empty? 123isEmpty()&#123; return this.length() === 0&#125; length 123length()&#123; return this.size - this.smallSize&#125;","categories":[],"tags":[{"name":"스터디","slug":"스터디","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"}]},{"title":"2020 회고","slug":"2020-회고","date":"2021-01-01T14:01:58.000Z","updated":"2021-01-17T14:50:08.882Z","comments":true,"path":"2021/01/01/2020-회고/","link":"","permalink":"https://hackertaco.github.io/2021/01/01/2020-%ED%9A%8C%EA%B3%A0/","excerpt":"","text":"피자를 끝내다. 이게 2020년의 일이라니.. 까마득하다! 처음으로 react 프로젝트를 했다. 근데 처음으로 redux도 만졌다. saga까지 하라는데 도저히 엄두가 안났다.. 그래도 이쁜 페이지가 나와서 만족 ! 같이 프로젝트 하던 친구들이 모두 취업을 했다. 모두 잘돼서 다행,,, 노드랩을 시작하다. 믹스인 프로젝트 참여하다. 혼자만의 프로젝트 뷰를 공부하다. 개발자로 취직하다. 번외 - 기획","categories":[],"tags":[{"name":"개발뉴비","slug":"개발뉴비","permalink":"https://hackertaco.github.io/tags/%EA%B0%9C%EB%B0%9C%EB%89%B4%EB%B9%84/"}]},{"title":"자료구조 4 stack","slug":"자료구조-4-stack","date":"2020-12-28T05:19:04.000Z","updated":"2020-12-31T09:37:46.159Z","comments":true,"path":"2020/12/28/자료구조-4-stack/","link":"","permalink":"https://hackertaco.github.io/2020/12/28/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-4-stack/","excerpt":"","text":"stack? 자료의 입출력이 한 방향에서만 이루어진다.queue와 같이 선형적 구조를 가지지만, 다른 부분이 있다.데이터를 삭제하는 순서가 다르다!LIFO 제일 마지막에 들어간 요소를 제일 먼저 빼는! queue와 비슷하게, 데이터를 제일 뒤에 집어넣는 삽입, 뒤에서 빼는 삭제 등의 작업이 가능하다.삽입을 하는 enqueue의 경우 O(1), 삭제를 하는 dequeue의 경우 O(1)의 복잡도를 가진다.접근을 하는 경우 O(n)의 복잡도를 가진다. use case? 즉각적으로 삽입, 삭제가 가능해 많이 사용된다. JavaScript call stack Applications that implement undo/redo Applications that include recently used Any data that needs to be handled with Last In First Out logic 구현javascript로는 배열을 이용해 아- 주 간단히, shift()과 unshift(), 혹은 push() pop()으로 queue의 핵심 기능을 구현할 수 있다.그러나 링크드 리스트를 이용해 봄.shift()와 unshift()개념으로 기능을 구현할 것. 그 이유는 linked list에는 next만 있고 previous는 없기 때문에, pop()을 구현할 경우 O(n)이 나온다. declare 123456789101112131415class Node &#123; constructor(data) &#123; this.data = data; this.next = null; &#125;&#125;class Stack &#123; constructor() &#123; //data가 따로 없으므로 parameter x this.head = null; this.tail = null; this.length = 0; &#125;&#125; unshift using linked list 12345678910111213unshift(data)&#123; let node = new Node(data); if(!this.head)&#123; this.head = node; this.tail = node; &#125;else&#123; node.next = this.head this.head = node &#125; this.length ++; return this.length;&#125; shift using linked list 12345678910111213141516shift()&#123; let data = null; if(!this.head)&#123; &#125;else if(this.length === 1)&#123; this.head = null; this.tail = null; this.length--; &#125;else&#123; this.head = this.head.next; this.length --; &#125;&#125;","categories":[],"tags":[{"name":"스터디","slug":"스터디","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"}]},{"title":"자료구조 3 Queue","slug":"자료구조-3-Queue","date":"2020-12-27T13:52:36.000Z","updated":"2020-12-31T09:37:47.779Z","comments":true,"path":"2020/12/27/자료구조-3-Queue/","link":"","permalink":"https://hackertaco.github.io/2020/12/27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-3-Queue/","excerpt":"","text":"queue? Queue는 FIFO, 즉 선입 선출형 자료형이다. the queues of bus stop 즉, 버스정류장에서 따온 queue는 먼저 온 사람(제일 오래 기다린 사람)이 제일 먼저 탄다는 원리를 그대로 따왔다. 데이터를 제일 뒤에 집어넣는 enqueue, 데이터를 제일 앞에서 추출하는 dequeue 등의 작업이 가능하다.삽입을 하는 enqueue의 경우 O(1), 삭제를 하는 dequeue의 경우 O(1)의 복잡도를 가진다.접근을 하는 경우 O(n)의 복잡도를 가진다. use case? 즉각적으로 삽입, 삭제가 가능해 많이 사용된다. Game servers that pair you up with other users (any networking to handle congestion) Any waiting line Background tasks Printer processes Traversing a Binary Search Tree or a Graph 구현javascript로는 배열을 이용해 아- 주 간단히, pop()과 unshift()로 queue의 핵심 기능을 구현할 수 있다.그러나 링크드 리스트를 이용해 봄. declare 123456789101112131415class Node &#123; constructor(data) &#123; this.data = data; this.next = null; &#125;&#125;class Queue &#123; constructor() &#123; //data가 따로 없으므로 parameter x this.head = null; this.tail = null; this.length = 0; &#125;&#125; enqueue using linked list 123456789101112131415enqueue(data)&#123; let node = new Node(data); //1. 리스트에 아무것도 없을 경우 if(!this.head)&#123; this.head = node; this.tail = node; &#125; else &#123; //2. 뭔가가 있을 경우 this.tail.next = node; this.tail = node; &#125; this.length ++; return this.length; // length 반환&#125; dequeue using linked list 12345678910111213141516dequeue()&#123; let data = null; if(!this.head)&#123; &#125;else if(this.length === 1)&#123; data = this.head.data; this.head = null; this.tail = null; this.length--; &#125;else&#123; data = this.head.data; this.head = this.head.next; this.length--; &#125; return data;&#125;","categories":[],"tags":[{"name":"스터디","slug":"스터디","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"}]},{"title":"자료구조 2. doubly linked list, circular linked list","slug":"자료구조-2-doubly-linked-list-circular-linked-list","date":"2020-12-24T05:05:42.000Z","updated":"2020-12-24T09:19:38.596Z","comments":true,"path":"2020/12/24/자료구조-2-doubly-linked-list-circular-linked-list/","link":"","permalink":"https://hackertaco.github.io/2020/12/24/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-2-doubly-linked-list-circular-linked-list/","excerpt":"","text":"doubly linked list 일반 연결 리스트가 next 포인터를 하나만 가지고 있어서 일방향이었다면,doubly linked list는 양방향! 2개의 연결 포인트를 가지고 있다. use case ?그런데 말입니다. doubly linked list는 실제로 어디에 쓰일까.뭐 뒤로가기 이런 거 할 때 쓰이나? 찾아보니, (출처)생각보다 다양한 부분에 쓰이고 있었다. 네비게이션의 앞과 뒤를 표현할 때. 뒤로가기, 앞으로 가기 (브라우저) undo redo 게임 패 게임의 여러 상태를 표현할 때 여튼 앞에서 뒤를 기억해야 하는 일이 있는 경우, 자주 사용되는 것으로 보인다. 구현 node class 1234567class Node &#123; constructor(data) &#123; this.data = data; this.next = null; this.prev = null; &#125;&#125; create node head, tail 선언 123456const head = new Node(1);const secondNode = new Node(2);head.next = secondNode;secondNode.prev = head;const tail = secondNode; 이렇게 선언한 걸로 순회 가능! 123456//head에서 순회let current = head;while (current !== null) &#123; current = current.next;&#125; 12345let current = tail;while (current !== null) &#123; current = current.prev;&#125; list create 이렇게 만든 node들로, doubly linked list class를 만들어볼 수 있다. 함께 list 에 data를 추가, 삭제, 검색 등이 가능하다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const head = Symbol(&quot;head&quot;);const tail = Symbol(&quot;tail&quot;);class DoublyLinkedList &#123; constructor() &#123; this.head = null; this.tail = null; &#125; // 1. add data O(1), 아무 순회도 하지 않으므로 ! add(data) &#123; const firstNode = new Node(data); if (this.head === null) &#123; this.head = firstNode; &#125; else &#123; this.tail.next = firstNode; firstNode.prev = this.tail; //tail과 연결 &#125; // tail에 재할당 this.tail = firstNode; &#125; //2. get data O(n), get(index) &#123; if (index &gt; -1) &#123; let current = this.head; let i = 0; while (current !== null &amp;&amp; i &lt; index) &#123; current = current.next; i++; &#125; return current !== null ? current.data : undefined; &#125; else &#123; return undefined; &#125; &#125; //3. remove data in list O(n) remove(index) &#123; if (this.head === null || index &lt; 0) &#123; throw new RangeError(`Index $&#123;index&#125; does not exist in the list.`); &#125; if (index === 0) &#123; this.head = this.head.next; if (this.head === null) &#123; this.tail = null; &#125; else &#123; this.head.prev = null; &#125; &#125; let current = this.head; let i = 0; while (this.head !== null &amp;&amp; index &gt; i) &#123; current = current.next; i++; &#125; if (current !== null) &#123; current.prev.next = current.next; if (this.tail === current) &#123; this.tail = current.prev; &#125; else &#123; current.next.prev = current.prev; &#125; &#125; &#125;&#125; 원형 연결리스트 다른 연결 리스트와 다른 점이라고 하면, data 값에 Null이 없다는 점 !tail data의 next가 head를 가리키기 때문이다.데이터들끼리 원형을 그려 원형 연결리스트라고 한다. 끝이 없음 !양방향, 단방향 모두 구현 가능하다. 이용 시 장점 모든 리스트가 어디서든 순회 가능 단방향이더라도 우리는 이전 노드로 갈 수 있다. 이용 시 단점 상대적으로 거꾸로 가는 것이 복잡 제대로 조정하지 않으면 무한 루프 즉각적인 데이터 접근 불가 (다른 리스트처럼) use case OS에서 사용. 다양한 어플리케이션 이용을 위해. round robin처럼 시간 매커니즘에 사용 돌아가면서 하는 멀티플레이어 게임에 사용. 구현 단방향, 원형 연결 리스트로 만들어보겠다. circular list를 위한 node가 정의되어있다고 가정 후 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//tail이 없다 !class CircularList&#123; const head = Symbol(&#x27;head&#x27;); constructor()&#123; this.head = null; this.length = 0; &#125; push(data)&#123; //끝에 집어넣는 것. 아예 head 가 null인 경우가 있고 아닌 경우가 있다. const newNode = new Node(data); if(this.head === null)&#123; this.head = newNode; newNode.next = this.head; &#125;else&#123; // 끝을 찾아야. let current = this.head while(current !== null)&#123; current = current.next; &#125; current = newNode; this.length++ newNode.next = this.head; &#125; &#125; insert(data, index)&#123; // 중간에 끼워넣는 것 if(index &gt;= 0 &amp;&amp; index &lt;= this.length)&#123; const newNode = new Node(data); let current = this.head; if(index === 0)&#123; if(this.head === null)&#123; this.head = newNode; newNode.next = this.head; &#125;else&#123; this.head.next = current; this.head = newNode &#125;; &#125;else if(index == this.length -1)&#123; while(current !== null)&#123; current = current.next &#125; current = newNode; current.next = this.head &#125;else&#123; let target = get(index-1); current = target.next; target.next = newNode; newNode.next = current &#125; this.length++ &#125; &#125; get(index)&#123; let counter = 0; let current = this.head; while(counter &lt; index)&#123; current = current.next; counter++ &#125; return current &#125; removeAt(index)&#123; if (index &gt;= 0 &amp;&amp; index &lt; this.length) &#123; if (this.head === null) &#123; return null &#125; let current = this.head; if (index == 0) &#123; this.head = current.next; &#125; else if(index == this.length-1) &#123; let target = get(index-1) current = target.next; target.next = this.head; &#125;else&#123; let target = get(index - 1); current = target.next; target.next = current.next; &#125; this.length --; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"릿코드 죄다 풀어보기","slug":"릿코드-죄다-풀어보기","date":"2020-12-18T08:29:44.000Z","updated":"2020-12-27T16:18:29.576Z","comments":true,"path":"2020/12/18/릿코드-죄다-풀어보기/","link":"","permalink":"https://hackertaco.github.io/2020/12/18/%EB%A6%BF%EC%BD%94%EB%93%9C-%EC%A3%84%EB%8B%A4-%ED%92%80%EC%96%B4%EB%B3%B4%EA%B8%B0/","excerpt":"","text":"쉬운 것 부터 시작해서 죄다 풀기 (하루에 1문제씩) two sum 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123; for (let i = 0; i &lt; nums.length; i++) &#123; target = target - nums[i]; const index = nums.indexOf(target); const nIndex = nums.indexOf(target, i + 1); if (nIndex === -1 &amp;&amp; i === index) &#123; target = target + nums[i]; continue; &#125; if (nIndex &gt; i) &#123; nums = [i, nIndex]; &#125; else &#123; target = target + nums[i]; &#125; &#125; return nums;&#125;; reverse integer 1234567891011121314151617181920212223242526/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function (x) &#123; let a = x.toString(); a = a.split(&quot;&quot;); let b = []; for (let i = 0; i &lt; a.length; i++) &#123; b[i] = a[a.length - 1 - i]; &#125; if (b[b.length - 1] === &quot;-&quot;) &#123; b.unshift(b.pop()); &#125; b = b.join(&quot;&quot;); if (b[0] == 0 &amp;&amp; b.length &gt; 1) &#123; b = b.slice(1); &#125; b = Number.parseInt(b); if (b &gt; Math.pow(2, 31) - 1 || b &lt; -Math.pow(2, 31)) return 0; return b;&#125;; Palindrome Number 123456789101112131415161718192021222324/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function (x) &#123; if (x &lt; 0 || x &gt; Math.pow(2, 31) - 1) return false; let y = 0; const z = x; while (x &gt; 0) &#123; y = 10 * y; y = y + (x % 10); x = x - (x % 10); x = x / 10; console.log(x, y); &#125; console.log(z); if (z === y) &#123; return true; &#125; else &#123; return false; &#125;&#125;; roman to integer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function (s) &#123; // i가 v나 x앞에 올 경우 iv ix // x가 l이나 c 앞에 올 경우 xl xc // c가 d나 m앞에 올 경우 cd cm // 웬만하면 뒤에 오는 걸 더해준다. 다만, 위 세 경우에는 빼준다. const i = 1; const v = 5; const x = 10; const l = 50; const c = 100; const d = 500; const m = 1000; let arr = []; let sum = 0; let sampleIndexI = 16; let sampleIndexX = 16; let sampleIndexC = 16; for (let str of s) &#123; console.log(sum); if (str === &quot;I&quot;) &#123; let index = s.indexOf(str); if ( index &lt; s.lastIndexOf(&quot;X&quot;) || (index &lt; s.lastIndexOf(&quot;V&quot;) &amp;&amp; sampleIndexI &gt; index) ) &#123; sum -= i; sampleIndexI = index; &#125; else &#123; sum += i; &#125; &#125; else if (str === &quot;V&quot;) &#123; sum += v; &#125; else if (str === &quot;X&quot;) &#123; let index = s.indexOf(str); if ( (index &lt; s.lastIndexOf(&quot;L&quot;) || index &lt; s.lastIndexOf(&quot;C&quot;)) &amp;&amp; sampleIndexX &gt; index ) &#123; sum -= x; sampleIndexX = index; &#125; else &#123; sum += x; &#125; &#125; else if (str === &quot;L&quot;) &#123; sum += l; &#125; else if (str === &quot;C&quot;) &#123; const index = s.indexOf(str); if ( (index &lt; s.lastIndexOf(&quot;D&quot;) || index &lt; s.lastIndexOf(&quot;M&quot;)) &amp;&amp; sampleIndexC &gt; index ) &#123; console.log(sampleIndexC); sum -= c; sampleIndexC = index; console.log(sampleIndexC); console.log(index); &#125; else &#123; sum += c; &#125; &#125; else if (str === &quot;D&quot;) &#123; sum += d; &#125; else if (str === &quot;M&quot;) &#123; sum += m; &#125; &#125; return sum;&#125;; longest common prefix그지같은 코드 짰음 12345678910111213141516171819202122let firstLetter = &quot;&quot;;strs = strs.sort((a, b) =&gt; &#123; return a.length - b.length;&#125;);firstLetter = strs[0];strs = strs.map((s) =&gt; s.slice(0, firstLetter.length));let i = 0;if (!strs[0]) return &quot;&quot;;while (i &lt; strs[0].length) &#123; if (!strs.every((s) =&gt; s[i] === strs[0][i])) &#123; firstLetter = strs[0].slice(0, i); return firstLetter; &#125; firstLetter = strs[0].slice(0, i + 1); i++;&#125;return firstLetter;","categories":[],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hackertaco.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]},{"title":"자료구조 1. 배열, 연결 리스트","slug":"자료구조 배열 연결리스트","date":"2020-12-16T10:27:28.000Z","updated":"2020-12-24T05:57:23.795Z","comments":true,"path":"2020/12/16/자료구조 배열 연결리스트/","link":"","permalink":"https://hackertaco.github.io/2020/12/16/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%20%EB%B0%B0%EC%97%B4%20%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/","excerpt":"","text":"배열이란 ? 굉장히 흔히 사용되는 자료구조. 연관된 데이터를 하나의 변수에 그룹핑한 뒤 관리하기 위한 방법. -&gt; 반복문과 연결시 효율적 정보 처리 가능. 데이터를 연속 저장하기 위해 내장된 형태로 제공한다. 그래서 heap이 아닌 stack에 쌓인다. 수학적 배열의 정의 1차원적인 묶음. [f(1),f(2),f(3),f(4),f(5),f(6)] == [3,1,-1,2,0,6] f(x)의 정의역(x)의 집합을 인덱스들(indices) 이라고 하며, 그 치역(f(x))의 집합을 Array라고 부른다. 치역과 인덱스를 합쳐서 엘리먼트라고 한다. js에서의 정의 정적인 언어들, 특히 C언어 같은 오래된 언어의 경우 컴파일 단계에서 Array의 크기, 형태, 값이 미리 정해져 있어야 한다. 그래서 array를 작은 크기로 선언하고 더 많은 값을 집어 넣으면 에러가 발생한다. 그러나 js에서는 객체 지향 언어 ! 객체로 제공한다. 1234let arr = [];arr[2] = 10;let arr2 = new Array(); 객체로 제공하기 때문에 Array를 선언만 하고, 값을 추가하는 방식을 사용한다. 타입도 상관없고, 상당히 유연쓰 이 배열을 이용해서 리스트를 구현해볼 수 있다. 배열을 기반으로 구현된 리스트를 순차 리스트라고 한다. 이 순차 리스트는 데이터를 나란히 저장하고, 중복된 데이터의 저장을 막지 않는다. 배열의 단점 배열은 인덱스를 이용해 편히 데이터 표현을 할 수 있다. 검색의 경우 시간 복잡도가 O(1) 그러나 중간에 빈 데이터, 즉 삭제와 같은 일이 발생했을 때, 데이터가 존재하지 않으므로 인덱스만 존재하고 나머지는 null로 처리가 돼버리는 문제 더불어 이를 정리하기 위해서 O(n)의 시간 복잡도가 생길 수 있는 문제가 있다. 그래서, 인덱스가 중요한 경우에는 배열을 사용하면 좋지만, 그게 아니라면 (추가나 삭제의 경우)그냥 연속적으로 (빈틈없이) 데이터가 위치하는 연결 리스트를 사용하는 것이 좋을 수 있다. 단일 연결 리스트 ?목적과 이론 위 사진과 같이, 단일 연결 리스트는 엘리먼트와 엘리먼트 간의 연결을 이용해 리스트를 구현한 것이다. 여기서 언급하는 엘리먼트는 배열의 엘리먼트와는 다르다. 배열의 엘리먼트는 인덱스와 데이터였다면, 연결 리스트에서는 노드 혹은 버텍스라는 개념으로 불리운다. 노드는 노드의 값과 다음 노드 즉, 포인터를 가지고 있어야 한다. 배열에 비해 추가나 삭제가 용이하다. 만약 c 언어라면 위와 같이 노드를 구조체로 구현하고, java와 같은 객체지향 언어의 경우 객체에 데이터 필드와 링크 필드를 만들게 된다. 데이터 필드는 보통 value 라는 이름의 변수, 링크 필드는 next 변수를 사용한다. use case in CSImplementation of stacks and queuesImplementation of graphs : Adjacency list representation of graphs is most popular which is uses linked list to store adjacent vertices.Dynamic memory allocation : We use linked list of free blocks.Maintaining directory of namesPerforming arithmetic operations on long integersManipulation of polynomials by storing constants in the node of linked listrepresenting sparse matrices head? 첫번째 노드를 말한다. 이를 찾아야 다음의 데이터들도 연결지어 찾아낼 수 있다. 구현 로직 java 언어를 사용 12345678910public class SinglyLinkedList &#123; Node head; class Node &#123; int data; Node next; Node(int d) &#123; data = d; &#125; &#125;&#125; 다이어그램과 연결지어 생각해 본다면, 각각의 네모는 노드, 제일 처음에 있는 노드는 헤드, 그곳에 적힌 숫자는 data, 다음을 가리키는 화살표는 next라고 할 수 있겠다. 여기서 다른 오퍼레이션, 예를 들면 insert나 remove를 구현해 본다면? 1234567891011public void insert(int data) &#123; Node newHead = new Node(data); if (head == null) &#123; head = newHead; return; &#125; newHead.next = head; head = newHead; &#125; 이는 집어넣는 데이터가 head 자리에 올 때의 구현. 12345678910public void remove(int data) &#123; Node preNode = head; Node tempNode = head.next; head = preNode.next; preNode.next = null; &#125; 이는 삭제할 데이터가 head에 있을 때ㅡ 그 외에도 조회, 데이터 중간에서 삽입, 끝에 삽입, 중간 삭제 끝 삭제 등등이 있다.","categories":[],"tags":[{"name":"스터디","slug":"스터디","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"}]},{"title":"cs스터디","slug":"cs스터디-1-시간복잡도-공간복잡도","date":"2020-12-13T14:39:39.000Z","updated":"2021-01-15T14:13:05.992Z","comments":true,"path":"2020/12/13/cs스터디-1-시간복잡도-공간복잡도/","link":"","permalink":"https://hackertaco.github.io/2020/12/13/cs%EC%8A%A4%ED%84%B0%EB%94%94-1-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/","excerpt":"","text":"1. cs 스터디 모집 개발 네트웤 모임에서, cs 스터디에 대한 열망이 뿜뿜해져서,,, 스터디를 구하게 되었따. 2. 학습 계획 아직 거창하지는 않으나, 알고리즘과 자료구조 이론을 공부할 생각이다. 3. 시간 복잡도? 공간 복잡도 ? 알아서 공부하기로. 아직 완전히 이해는 어렵지만, 시간 복잡도는 프로세스 관련한, 공간 복잡도는 메모리와 관련한 부분이라는 것을 알게 되었다. 4. 알고리즘배열 189. Rotate Array12345678910111213141516&#x2F;** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;void&#125; Do not return anything, modify nums in-place instead. *&#x2F;var rotate &#x3D; function(nums, k) &#123; const newNums &#x3D; nums.splice(nums.length-k, k); nums.unshift(...newNums)&#x2F;&#x2F; for(let i &#x3D; 0; i&lt;k; i++)&#123;&#x2F;&#x2F; nums.unshift(nums.pop())&#x2F;&#x2F; &#125;&#125;; 배열 56. Merge Intervals123456789101112&#x2F;** * @param &#123;number[][]&#125; intervals * @return &#123;number[][]&#125; *&#x2F;var merge &#x3D; function(intervals) &#123; const merging &#x3D; (acc, cur) &#x3D;&gt; (!acc.length || acc[acc.length - 1][1] &lt; cur[0] ? acc.push(cur) : acc[acc.length - 1][1] &#x3D; Math.max(acc[acc.length-1][1], cur[1]),acc) return intervals.sort((a,b) &#x3D;&gt; a[0] - b[0]).reduce(merging,[]);&#125; 단순 연결 리스트 876. Middle of the Linked List123456789101112131415161718192021let middleNode &#x3D; function(head) &#123; let targetLen &#x3D; Math.ceil(getLen(head)&#x2F;2); return returnAtPosition(head, targetLen);&#125;;let getLen &#x3D; function(node) &#123; let length &#x3D; 0; while(node.next) &#123; length +&#x3D; 1; node &#x3D; node.next; &#125; return length;&#125;;let returnAtPosition &#x3D; function(node, targetLen) &#123; for(let i &#x3D; 0; i &lt; targetLen; i++) &#123; node &#x3D; node.next; &#125; return node; 단순 연결 리스트 92. Reverse Linked List II12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#x2F;** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val) * this.next &#x3D; (next&#x3D;&#x3D;&#x3D;undefined ? null : next) * &#125; *&#x2F;&#x2F;** * @param &#123;ListNode&#125; head * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;ListNode&#125; *&#x2F;var reverseBetween &#x3D; function(head, m, n) &#123; &#x2F;** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val) * this.next &#x3D; (next&#x3D;&#x3D;&#x3D;undefined ? null : next) * &#125; *&#x2F;&#x2F;** * @param &#123;ListNode&#125; head * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;ListNode&#125; *&#x2F;var reverseBetween &#x3D; function(head, m, n) &#123; if (head &#x3D;&#x3D;&#x3D; null) return head; const dummy &#x3D; new ListNode(0); dummy.next &#x3D; head; let cur &#x3D; head; let prev &#x3D; dummy; for(let i &#x3D; 1; i&lt;m; i++)&#123; cur &#x3D; cur.next; &#x2F;&#x2F;2345 prev &#x3D; prev.next &#x2F;&#x2F;12345 &#125; for(let j &#x3D; m; j&lt;n; j++)&#123; let temp &#x3D; cur.next; cur.next &#x3D; temp.next; temp.next &#x3D;prev.next; prev.next &#x3D; temp &#125; return dummy.next&#125;;&#125;;","categories":[],"tags":[{"name":"스터디","slug":"스터디","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"}]},{"title":"개발일기","slug":"개발일기","date":"2020-12-02T14:34:28.000Z","updated":"2020-12-17T10:04:52.180Z","comments":true,"path":"2020/12/02/개발일기/","link":"","permalink":"https://hackertaco.github.io/2020/12/02/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EA%B8%B0/","excerpt":"","text":"01. 비전공자 개발 뉴비로 살아간다는 것123어릴때부터 기술 가정 과목 중에 기술을 겁나 싫어했다. 나는 정말 오만거에 관심을 두는 성격인데도, 이상하게 성격조사나 적성 검사를 하면 기술에는 거의 빵점이 나왔다.그래서 개발은 인생에서 절대 나와 관련이 없을 것이라고 생각했다. 02. 개발은 도구라고 생각한다.123456789101112그러다,서비스 기획자로 회사에 다녔다. 개발에 관심이 생겼다.기획은 내가 상상한 것을 구체적으로 설명할 수 있는 직무다.다만, 문제는 기획은 어디까지나 &#39;현실 속에서&#39; 상상한 것을 구체화해야 한다는 것이었다.금전, 지금 당장의 고객, 개발자와의 소통 등 현실의 벽과 마주한 그 수많은 날들.조금은 무력감을 느끼던 그 때, 개발을 시작했다.내가 상상해오던 것을 만들 수 있는 세상은 너무도 멋진 세상.상상을 실제로 구현할 수 있는 것은 너무도 멋진 일.내가 할 수 있는 것과 잘 하는 일이 합쳐져있다고 생각했다.내가 서비스 기획에서 느낀 한계를 개발자로서 재밌게 풀어나갈 수 있을 것 같았다. 03. 하지만 개발을 잘하려면 개발이 목적이 되어야 할지도.123456789그러나 개발을 잘하는 거슨 너무도 어려운 일이었으니, 좋아해야 개발을 할 수 있다.매일 마주하는 수많은 버그들과 똥같은 코드들을 보면서아 이걸 고쳐내보자 하는 도전과 용기가 매번 필요한 것이 어려웠다.그래서,어렵고 빠르게 변하고 다양한 층위의 지식이 섞인 이 곳의 지식은,흥미가 필수 불가결한 요소.거기에 적성까지 붙는다면 정말 금상첨화지만,그런 복받은 사람이 세상에 얼마나 될까. 04. 그 속에서 나의 비전과 목표1234나는 복받지는 않았지만, 그럼에도 개발을 해야하는 건,내가 만들어왔고 만들고싶은 수많은 재미난 것들이 개발로 가능하다고 믿기 때문이다.존버하면 어떠케 되지않을까요..? 그렇다구 해주세요,,ㅎ","categories":[],"tags":[]},{"title":"vue3를 처음으로 맞이하는 0년차개발자(1)","slug":"my-new-post","date":"2020-10-19T14:27:31.000Z","updated":"2020-12-17T10:05:14.481Z","comments":true,"path":"2020/10/19/my-new-post/","link":"","permalink":"https://hackertaco.github.io/2020/10/19/my-new-post/","excerpt":"","text":"마크다운으로 처음 글도 써보고, 뷰3도 투두리스트 구현까지 해본 초보 개발(희망)자.뷰로 관리자페이지를 만드는 그 날까지..! 열싐히 기록해볼 것이다. 1. vue3 tutorial을 찾다 유튭에 아무거나 때려 공부하기 2. vue 개략한 줄 요약 : 뷰는 적응하기 쉬워! 프레임워크 안에서 놀면 된다.뷰를 말해보자면 웹 페이지를 만드는 것을 도와주는!(리액트랑 비교해보자면, 리액트는 상대적으로 라이브러리의 성격이 강해서 js를 좀 잘해야 한다.) 뷰를 실행하는 가장 쉬운 방법은 cdn 사용 를 html head tag 안에 넣어주면 된다. 그러면 ! 3. 잡다한 지식 조각 뷰 3부터는 data가 함수의 모양을 하고 있어야 한다. vetur는 뷰 글자 자동완성 내지는 템플릿 자동완성 해주는 아주 조은 익스텐션 vue devtool로 많은 걸 할 수 있지. v-model은 data와 화면 둘다 묶는다. 4. directives 뷰에는 directives라는 지시어가 있다. 이는 template과 script를 서로 연결해주는 어떤것으로 우선 이해했다. data, computed, methods 등을 모두 연결할 수 있다. 그 중 한 예로 v-model은 input과 같이 html태그 중 어떤 것을 에력하는 태그인 경우에, vue script tag 내의 데이터와 입력 값을 서로 연결해준다. v-once는 렌더링이 딱 한번 되는 것. 5. vue router 라우터가 있어야 하는 이유는 vue가 SPA 즉, single page application 인 것과 관계가 있다. SPA는 최초 한번만 전체 페이지를 로딩한 후 데이터만 변경해서 사용하는 어플리케이션이다. 이 SPA는 html, js와 같은 파일을 렌더링할 때 클라이언트 사이드 렌더링이라는 방식을 이용한다. 기본적으로 페이지가 따로 없다 (single page니까!) 모든 페이지는 단순히 HTML5 History에 의해 렌더링 될 뿐이다. 그래서 언제 새 데이터를 불러와야 할지를 스스로 정해야 한다. 즉 사용자의 행동에 따라 어떤 데이터가 불려올지가 정해진다. SPA라고 할지라도 한 종류의 화면만 있는 것은 아니다 ! 화면에 따라 다른 주소를 가진다. 주소에 따라 여러 뷰를 렌더링하는 것을 라우팅이라고 하고, vue 자체에는 이 기능이 내장돼있지 않다. 대신 vue-router가 있다. 그러니까, 일단 vue-router를 add 해준다. 라우터를 통해 변할 페이지의 위치에서, 를 써줘 링크를 넣을 곳에 router-link 태그 main.js에 난 라우터를 쓸 것이라고 이야기해줘야한다. createApp(App).use(router) 이렇게? default mode는 hash mode이다. SPA 환경에서 바뀐 부분만 렌더링해주어야 하기에 hash(#)를 써서 full URL을 시뮬레이트하기 때문. 만일 이 해쉬를 없애고 싶다면, 라우터의 히스토리모드를 사용할 수 있다.","categories":[],"tags":[{"name":"개발뉴비","slug":"개발뉴비","permalink":"https://hackertaco.github.io/tags/%EA%B0%9C%EB%B0%9C%EB%89%B4%EB%B9%84/"}]}],"categories":[],"tags":[{"name":"스터디","slug":"스터디","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"},{"name":"개발뉴비","slug":"개발뉴비","permalink":"https://hackertaco.github.io/tags/%EA%B0%9C%EB%B0%9C%EB%89%B4%EB%B9%84/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://hackertaco.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]}