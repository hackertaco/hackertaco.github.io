{"meta":{"title":"0년차 개발자의 블로그","subtitle":"happy hacking중!","description":"","author":"hackertaco","url":"https://hackertaco.github.io","root":"/"},"pages":[],"posts":[{"title":"자료구조 4 stack","slug":"자료구조-4-stack","date":"2020-12-28T05:19:04.000Z","updated":"2020-12-28T05:23:17.282Z","comments":true,"path":"2020/12/28/자료구조-4-stack/","link":"","permalink":"https://hackertaco.github.io/2020/12/28/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-4-stack/","excerpt":"","text":"stack?자료의 입출력이 한 방향에서만 이루어진다.LIFO 제일 마지막에 들어간 요소를 제일 먼저 빼는!","categories":[],"tags":[]},{"title":"자료구조 3 Queue","slug":"자료구조-3-Queue","date":"2020-12-27T13:52:36.000Z","updated":"2020-12-31T07:31:19.833Z","comments":true,"path":"2020/12/27/자료구조-3-Queue/","link":"","permalink":"https://hackertaco.github.io/2020/12/27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-3-Queue/","excerpt":"","text":"queue? Queue는 FIFO, 즉 선입 선출형 자료형이다. 데이터를 집어넣는 enqueue, 데이터를 추출하는 dequeue 등의 작업이 가능하다.","categories":[],"tags":[{"name":"스터디 자료구조","slug":"스터디-자료구조","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"}]},{"title":"자료구조 2. doubly linked list, circular linked list","slug":"자료구조-2-doubly-linked-list-circular-linked-list","date":"2020-12-24T05:05:42.000Z","updated":"2020-12-24T09:19:38.596Z","comments":true,"path":"2020/12/24/자료구조-2-doubly-linked-list-circular-linked-list/","link":"","permalink":"https://hackertaco.github.io/2020/12/24/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-2-doubly-linked-list-circular-linked-list/","excerpt":"","text":"doubly linked list 일반 연결 리스트가 next 포인터를 하나만 가지고 있어서 일방향이었다면,doubly linked list는 양방향! 2개의 연결 포인트를 가지고 있다. use case ?그런데 말입니다. doubly linked list는 실제로 어디에 쓰일까.뭐 뒤로가기 이런 거 할 때 쓰이나? 찾아보니, (출처)생각보다 다양한 부분에 쓰이고 있었다. 네비게이션의 앞과 뒤를 표현할 때. 뒤로가기, 앞으로 가기 (브라우저) undo redo 게임 패 게임의 여러 상태를 표현할 때 여튼 앞에서 뒤를 기억해야 하는 일이 있는 경우, 자주 사용되는 것으로 보인다. 구현 node class 1234567class Node &#123; constructor(data) &#123; this.data = data; this.next = null; this.prev = null; &#125;&#125; create node head, tail 선언 123456const head = new Node(1);const secondNode = new Node(2);head.next = secondNode;secondNode.prev = head;const tail = secondNode; 이렇게 선언한 걸로 순회 가능! 123456//head에서 순회let current = head;while (current !== null) &#123; current = current.next;&#125; 12345let current = tail;while (current !== null) &#123; current = current.prev;&#125; list create 이렇게 만든 node들로, doubly linked list class를 만들어볼 수 있다. 함께 list 에 data를 추가, 삭제, 검색 등이 가능하다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const head = Symbol(&quot;head&quot;);const tail = Symbol(&quot;tail&quot;);class DoublyLinkedList &#123; constructor() &#123; this.head = null; this.tail = null; &#125; // 1. add data O(1), 아무 순회도 하지 않으므로 ! add(data) &#123; const firstNode = new Node(data); if (this.head === null) &#123; this.head = firstNode; &#125; else &#123; this.tail.next = firstNode; firstNode.prev = this.tail; //tail과 연결 &#125; // tail에 재할당 this.tail = firstNode; &#125; //2. get data O(n), get(index) &#123; if (index &gt; -1) &#123; let current = this.head; let i = 0; while (current !== null &amp;&amp; i &lt; index) &#123; current = current.next; i++; &#125; return current !== null ? current.data : undefined; &#125; else &#123; return undefined; &#125; &#125; //3. remove data in list O(n) remove(index) &#123; if (this.head === null || index &lt; 0) &#123; throw new RangeError(`Index $&#123;index&#125; does not exist in the list.`); &#125; if (index === 0) &#123; this.head = this.head.next; if (this.head === null) &#123; this.tail = null; &#125; else &#123; this.head.prev = null; &#125; &#125; let current = this.head; let i = 0; while (this.head !== null &amp;&amp; index &gt; i) &#123; current = current.next; i++; &#125; if (current !== null) &#123; current.prev.next = current.next; if (this.tail === current) &#123; this.tail = current.prev; &#125; else &#123; current.next.prev = current.prev; &#125; &#125; &#125;&#125; 원형 연결리스트 다른 연결 리스트와 다른 점이라고 하면, data 값에 Null이 없다는 점 !tail data의 next가 head를 가리키기 때문이다.데이터들끼리 원형을 그려 원형 연결리스트라고 한다. 끝이 없음 !양방향, 단방향 모두 구현 가능하다. 이용 시 장점 모든 리스트가 어디서든 순회 가능 단방향이더라도 우리는 이전 노드로 갈 수 있다. 이용 시 단점 상대적으로 거꾸로 가는 것이 복잡 제대로 조정하지 않으면 무한 루프 즉각적인 데이터 접근 불가 (다른 리스트처럼) use case OS에서 사용. 다양한 어플리케이션 이용을 위해. round robin처럼 시간 매커니즘에 사용 돌아가면서 하는 멀티플레이어 게임에 사용. 구현 단방향, 원형 연결 리스트로 만들어보겠다. circular list를 위한 node가 정의되어있다고 가정 후 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//tail이 없다 !class CircularList&#123; const head = Symbol(&#x27;head&#x27;); constructor()&#123; this.head = null; this.length = 0; &#125; push(data)&#123; //끝에 집어넣는 것. 아예 head 가 null인 경우가 있고 아닌 경우가 있다. const newNode = new Node(data); if(this.head === null)&#123; this.head = newNode; newNode.next = this.head; &#125;else&#123; // 끝을 찾아야. let current = this.head while(current !== null)&#123; current = current.next; &#125; current = newNode; this.length++ newNode.next = this.head; &#125; &#125; insert(data, index)&#123; // 중간에 끼워넣는 것 if(index &gt;= 0 &amp;&amp; index &lt;= this.length)&#123; const newNode = new Node(data); let current = this.head; if(index === 0)&#123; if(this.head === null)&#123; this.head = newNode; newNode.next = this.head; &#125;else&#123; this.head.next = current; this.head = newNode &#125;; &#125;else if(index == this.length -1)&#123; while(current !== null)&#123; current = current.next &#125; current = newNode; current.next = this.head &#125;else&#123; let target = get(index-1); current = target.next; target.next = newNode; newNode.next = current &#125; this.length++ &#125; &#125; get(index)&#123; let counter = 0; let current = this.head; while(counter &lt; index)&#123; current = current.next; counter++ &#125; return current &#125; removeAt(index)&#123; if (index &gt;= 0 &amp;&amp; index &lt; this.length) &#123; if (this.head === null) &#123; return null &#125; let current = this.head; if (index == 0) &#123; this.head = current.next; &#125; else if(index == this.length-1) &#123; let target = get(index-1) current = target.next; target.next = this.head; &#125;else&#123; let target = get(index - 1); current = target.next; target.next = current.next; &#125; this.length --; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"릿코드 죄다 풀어보기","slug":"릿코드-죄다-풀어보기","date":"2020-12-18T08:29:44.000Z","updated":"2020-12-27T16:18:29.576Z","comments":true,"path":"2020/12/18/릿코드-죄다-풀어보기/","link":"","permalink":"https://hackertaco.github.io/2020/12/18/%EB%A6%BF%EC%BD%94%EB%93%9C-%EC%A3%84%EB%8B%A4-%ED%92%80%EC%96%B4%EB%B3%B4%EA%B8%B0/","excerpt":"","text":"쉬운 것 부터 시작해서 죄다 풀기 (하루에 1문제씩) two sum 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123; for (let i = 0; i &lt; nums.length; i++) &#123; target = target - nums[i]; const index = nums.indexOf(target); const nIndex = nums.indexOf(target, i + 1); if (nIndex === -1 &amp;&amp; i === index) &#123; target = target + nums[i]; continue; &#125; if (nIndex &gt; i) &#123; nums = [i, nIndex]; &#125; else &#123; target = target + nums[i]; &#125; &#125; return nums;&#125;; reverse integer 1234567891011121314151617181920212223242526/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function (x) &#123; let a = x.toString(); a = a.split(&quot;&quot;); let b = []; for (let i = 0; i &lt; a.length; i++) &#123; b[i] = a[a.length - 1 - i]; &#125; if (b[b.length - 1] === &quot;-&quot;) &#123; b.unshift(b.pop()); &#125; b = b.join(&quot;&quot;); if (b[0] == 0 &amp;&amp; b.length &gt; 1) &#123; b = b.slice(1); &#125; b = Number.parseInt(b); if (b &gt; Math.pow(2, 31) - 1 || b &lt; -Math.pow(2, 31)) return 0; return b;&#125;; Palindrome Number 123456789101112131415161718192021222324/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function (x) &#123; if (x &lt; 0 || x &gt; Math.pow(2, 31) - 1) return false; let y = 0; const z = x; while (x &gt; 0) &#123; y = 10 * y; y = y + (x % 10); x = x - (x % 10); x = x / 10; console.log(x, y); &#125; console.log(z); if (z === y) &#123; return true; &#125; else &#123; return false; &#125;&#125;; roman to integer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function (s) &#123; // i가 v나 x앞에 올 경우 iv ix // x가 l이나 c 앞에 올 경우 xl xc // c가 d나 m앞에 올 경우 cd cm // 웬만하면 뒤에 오는 걸 더해준다. 다만, 위 세 경우에는 빼준다. const i = 1; const v = 5; const x = 10; const l = 50; const c = 100; const d = 500; const m = 1000; let arr = []; let sum = 0; let sampleIndexI = 16; let sampleIndexX = 16; let sampleIndexC = 16; for (let str of s) &#123; console.log(sum); if (str === &quot;I&quot;) &#123; let index = s.indexOf(str); if ( index &lt; s.lastIndexOf(&quot;X&quot;) || (index &lt; s.lastIndexOf(&quot;V&quot;) &amp;&amp; sampleIndexI &gt; index) ) &#123; sum -= i; sampleIndexI = index; &#125; else &#123; sum += i; &#125; &#125; else if (str === &quot;V&quot;) &#123; sum += v; &#125; else if (str === &quot;X&quot;) &#123; let index = s.indexOf(str); if ( (index &lt; s.lastIndexOf(&quot;L&quot;) || index &lt; s.lastIndexOf(&quot;C&quot;)) &amp;&amp; sampleIndexX &gt; index ) &#123; sum -= x; sampleIndexX = index; &#125; else &#123; sum += x; &#125; &#125; else if (str === &quot;L&quot;) &#123; sum += l; &#125; else if (str === &quot;C&quot;) &#123; const index = s.indexOf(str); if ( (index &lt; s.lastIndexOf(&quot;D&quot;) || index &lt; s.lastIndexOf(&quot;M&quot;)) &amp;&amp; sampleIndexC &gt; index ) &#123; console.log(sampleIndexC); sum -= c; sampleIndexC = index; console.log(sampleIndexC); console.log(index); &#125; else &#123; sum += c; &#125; &#125; else if (str === &quot;D&quot;) &#123; sum += d; &#125; else if (str === &quot;M&quot;) &#123; sum += m; &#125; &#125; return sum;&#125;; longest common prefix그지같은 코드 짰음 12345678910111213141516171819202122let firstLetter = &quot;&quot;;strs = strs.sort((a, b) =&gt; &#123; return a.length - b.length;&#125;);firstLetter = strs[0];strs = strs.map((s) =&gt; s.slice(0, firstLetter.length));let i = 0;if (!strs[0]) return &quot;&quot;;while (i &lt; strs[0].length) &#123; if (!strs.every((s) =&gt; s[i] === strs[0][i])) &#123; firstLetter = strs[0].slice(0, i); return firstLetter; &#125; firstLetter = strs[0].slice(0, i + 1); i++;&#125;return firstLetter;","categories":[],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hackertaco.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]},{"title":"자료구조 1. 배열, 연결 리스트","slug":"자료구조 배열 연결리스트","date":"2020-12-16T10:27:28.000Z","updated":"2020-12-24T05:57:23.795Z","comments":true,"path":"2020/12/16/자료구조 배열 연결리스트/","link":"","permalink":"https://hackertaco.github.io/2020/12/16/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%20%EB%B0%B0%EC%97%B4%20%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/","excerpt":"","text":"배열이란 ? 굉장히 흔히 사용되는 자료구조. 연관된 데이터를 하나의 변수에 그룹핑한 뒤 관리하기 위한 방법. -&gt; 반복문과 연결시 효율적 정보 처리 가능. 데이터를 연속 저장하기 위해 내장된 형태로 제공한다. 그래서 heap이 아닌 stack에 쌓인다. 수학적 배열의 정의 1차원적인 묶음. [f(1),f(2),f(3),f(4),f(5),f(6)] == [3,1,-1,2,0,6] f(x)의 정의역(x)의 집합을 인덱스들(indices) 이라고 하며, 그 치역(f(x))의 집합을 Array라고 부른다. 치역과 인덱스를 합쳐서 엘리먼트라고 한다. js에서의 정의 정적인 언어들, 특히 C언어 같은 오래된 언어의 경우 컴파일 단계에서 Array의 크기, 형태, 값이 미리 정해져 있어야 한다. 그래서 array를 작은 크기로 선언하고 더 많은 값을 집어 넣으면 에러가 발생한다. 그러나 js에서는 객체 지향 언어 ! 객체로 제공한다. 1234let arr = [];arr[2] = 10;let arr2 = new Array(); 객체로 제공하기 때문에 Array를 선언만 하고, 값을 추가하는 방식을 사용한다. 타입도 상관없고, 상당히 유연쓰 이 배열을 이용해서 리스트를 구현해볼 수 있다. 배열을 기반으로 구현된 리스트를 순차 리스트라고 한다. 이 순차 리스트는 데이터를 나란히 저장하고, 중복된 데이터의 저장을 막지 않는다. 배열의 단점 배열은 인덱스를 이용해 편히 데이터 표현을 할 수 있다. 검색의 경우 시간 복잡도가 O(1) 그러나 중간에 빈 데이터, 즉 삭제와 같은 일이 발생했을 때, 데이터가 존재하지 않으므로 인덱스만 존재하고 나머지는 null로 처리가 돼버리는 문제 더불어 이를 정리하기 위해서 O(n)의 시간 복잡도가 생길 수 있는 문제가 있다. 그래서, 인덱스가 중요한 경우에는 배열을 사용하면 좋지만, 그게 아니라면 (추가나 삭제의 경우)그냥 연속적으로 (빈틈없이) 데이터가 위치하는 연결 리스트를 사용하는 것이 좋을 수 있다. 단일 연결 리스트 ?목적과 이론 위 사진과 같이, 단일 연결 리스트는 엘리먼트와 엘리먼트 간의 연결을 이용해 리스트를 구현한 것이다. 여기서 언급하는 엘리먼트는 배열의 엘리먼트와는 다르다. 배열의 엘리먼트는 인덱스와 데이터였다면, 연결 리스트에서는 노드 혹은 버텍스라는 개념으로 불리운다. 노드는 노드의 값과 다음 노드 즉, 포인터를 가지고 있어야 한다. 배열에 비해 추가나 삭제가 용이하다. 만약 c 언어라면 위와 같이 노드를 구조체로 구현하고, java와 같은 객체지향 언어의 경우 객체에 데이터 필드와 링크 필드를 만들게 된다. 데이터 필드는 보통 value 라는 이름의 변수, 링크 필드는 next 변수를 사용한다. use case in CSImplementation of stacks and queuesImplementation of graphs : Adjacency list representation of graphs is most popular which is uses linked list to store adjacent vertices.Dynamic memory allocation : We use linked list of free blocks.Maintaining directory of namesPerforming arithmetic operations on long integersManipulation of polynomials by storing constants in the node of linked listrepresenting sparse matrices head? 첫번째 노드를 말한다. 이를 찾아야 다음의 데이터들도 연결지어 찾아낼 수 있다. 구현 로직 java 언어를 사용 12345678910public class SinglyLinkedList &#123; Node head; class Node &#123; int data; Node next; Node(int d) &#123; data = d; &#125; &#125;&#125; 다이어그램과 연결지어 생각해 본다면, 각각의 네모는 노드, 제일 처음에 있는 노드는 헤드, 그곳에 적힌 숫자는 data, 다음을 가리키는 화살표는 next라고 할 수 있겠다. 여기서 다른 오퍼레이션, 예를 들면 insert나 remove를 구현해 본다면? 1234567891011public void insert(int data) &#123; Node newHead = new Node(data); if (head == null) &#123; head = newHead; return; &#125; newHead.next = head; head = newHead; &#125; 이는 집어넣는 데이터가 head 자리에 올 때의 구현. 12345678910public void remove(int data) &#123; Node preNode = head; Node tempNode = head.next; head = preNode.next; preNode.next = null; &#125; 이는 삭제할 데이터가 head에 있을 때ㅡ 그 외에도 조회, 데이터 중간에서 삽입, 끝에 삽입, 중간 삭제 끝 삭제 등등이 있다.","categories":[],"tags":[{"name":"스터디","slug":"스터디","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"}]},{"title":"cs스터디","slug":"cs스터디-1-시간복잡도-공간복잡도","date":"2020-12-13T14:39:39.000Z","updated":"2020-12-17T10:06:20.815Z","comments":true,"path":"2020/12/13/cs스터디-1-시간복잡도-공간복잡도/","link":"","permalink":"https://hackertaco.github.io/2020/12/13/cs%EC%8A%A4%ED%84%B0%EB%94%94-1-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/","excerpt":"","text":"1. cs 스터디 모집 개발 네트웤 모임에서, cs 스터디에 대한 열망이 뿜뿜해져서,,, 스터디를 구하게 되었따. 2. 학습 계획 아직 거창하지는 않으나, 알고리즘과 자료구조 이론을 공부할 생각이다. 3. 시간 복잡도? 공간 복잡도 ?4. 알고리즘배열 189. Rotate Array12345678910111213141516&#x2F;** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;void&#125; Do not return anything, modify nums in-place instead. *&#x2F;var rotate &#x3D; function(nums, k) &#123; const newNums &#x3D; nums.splice(nums.length-k, k); nums.unshift(...newNums)&#x2F;&#x2F; for(let i &#x3D; 0; i&lt;k; i++)&#123;&#x2F;&#x2F; nums.unshift(nums.pop())&#x2F;&#x2F; &#125;&#125;; 배열 56. Merge Intervals123456789101112&#x2F;** * @param &#123;number[][]&#125; intervals * @return &#123;number[][]&#125; *&#x2F;var merge &#x3D; function(intervals) &#123; const merging &#x3D; (acc, cur) &#x3D;&gt; (!acc.length || acc[acc.length - 1][1] &lt; cur[0] ? acc.push(cur) : acc[acc.length - 1][1] &#x3D; Math.max(acc[acc.length-1][1], cur[1]),acc) return intervals.sort((a,b) &#x3D;&gt; a[0] - b[0]).reduce(merging,[]);&#125; 단순 연결 리스트 876. Middle of the Linked List123456789101112131415161718192021let middleNode &#x3D; function(head) &#123; let targetLen &#x3D; Math.ceil(getLen(head)&#x2F;2); return returnAtPosition(head, targetLen);&#125;;let getLen &#x3D; function(node) &#123; let length &#x3D; 0; while(node.next) &#123; length +&#x3D; 1; node &#x3D; node.next; &#125; return length;&#125;;let returnAtPosition &#x3D; function(node, targetLen) &#123; for(let i &#x3D; 0; i &lt; targetLen; i++) &#123; node &#x3D; node.next; &#125; return node; 단순 연결 리스트 92. Reverse Linked List II12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#x2F;** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val) * this.next &#x3D; (next&#x3D;&#x3D;&#x3D;undefined ? null : next) * &#125; *&#x2F;&#x2F;** * @param &#123;ListNode&#125; head * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;ListNode&#125; *&#x2F;var reverseBetween &#x3D; function(head, m, n) &#123; &#x2F;** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val) * this.next &#x3D; (next&#x3D;&#x3D;&#x3D;undefined ? null : next) * &#125; *&#x2F;&#x2F;** * @param &#123;ListNode&#125; head * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;ListNode&#125; *&#x2F;var reverseBetween &#x3D; function(head, m, n) &#123; if (head &#x3D;&#x3D;&#x3D; null) return head; const dummy &#x3D; new ListNode(0); dummy.next &#x3D; head; let cur &#x3D; head; let prev &#x3D; dummy; for(let i &#x3D; 1; i&lt;m; i++)&#123; cur &#x3D; cur.next; &#x2F;&#x2F;2345 prev &#x3D; prev.next &#x2F;&#x2F;12345 &#125; for(let j &#x3D; m; j&lt;n; j++)&#123; let temp &#x3D; cur.next; cur.next &#x3D; temp.next; temp.next &#x3D;prev.next; prev.next &#x3D; temp &#125; return dummy.next&#125;;&#125;;","categories":[],"tags":[{"name":"스터디","slug":"스터디","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"}]},{"title":"개발일기","slug":"개발일기","date":"2020-12-02T14:34:28.000Z","updated":"2020-12-17T10:04:52.180Z","comments":true,"path":"2020/12/02/개발일기/","link":"","permalink":"https://hackertaco.github.io/2020/12/02/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EA%B8%B0/","excerpt":"","text":"01. 비전공자 개발 뉴비로 살아간다는 것123어릴때부터 기술 가정 과목 중에 기술을 겁나 싫어했다. 나는 정말 오만거에 관심을 두는 성격인데도, 이상하게 성격조사나 적성 검사를 하면 기술에는 거의 빵점이 나왔다.그래서 개발은 인생에서 절대 나와 관련이 없을 것이라고 생각했다. 02. 개발은 도구라고 생각한다.123456789101112그러다,서비스 기획자로 회사에 다녔다. 개발에 관심이 생겼다.기획은 내가 상상한 것을 구체적으로 설명할 수 있는 직무다.다만, 문제는 기획은 어디까지나 &#39;현실 속에서&#39; 상상한 것을 구체화해야 한다는 것이었다.금전, 지금 당장의 고객, 개발자와의 소통 등 현실의 벽과 마주한 그 수많은 날들.조금은 무력감을 느끼던 그 때, 개발을 시작했다.내가 상상해오던 것을 만들 수 있는 세상은 너무도 멋진 세상.상상을 실제로 구현할 수 있는 것은 너무도 멋진 일.내가 할 수 있는 것과 잘 하는 일이 합쳐져있다고 생각했다.내가 서비스 기획에서 느낀 한계를 개발자로서 재밌게 풀어나갈 수 있을 것 같았다. 03. 하지만 개발을 잘하려면 개발이 목적이 되어야 할지도.123456789그러나 개발을 잘하는 거슨 너무도 어려운 일이었으니, 좋아해야 개발을 할 수 있다.매일 마주하는 수많은 버그들과 똥같은 코드들을 보면서아 이걸 고쳐내보자 하는 도전과 용기가 매번 필요한 것이 어려웠다.그래서,어렵고 빠르게 변하고 다양한 층위의 지식이 섞인 이 곳의 지식은,흥미가 필수 불가결한 요소.거기에 적성까지 붙는다면 정말 금상첨화지만,그런 복받은 사람이 세상에 얼마나 될까. 04. 그 속에서 나의 비전과 목표1234나는 복받지는 않았지만, 그럼에도 개발을 해야하는 건,내가 만들어왔고 만들고싶은 수많은 재미난 것들이 개발로 가능하다고 믿기 때문이다.존버하면 어떠케 되지않을까요..? 그렇다구 해주세요,,ㅎ","categories":[],"tags":[]},{"title":"vue3를 처음으로 맞이하는 0년차개발자(1)","slug":"my-new-post","date":"2020-10-19T14:27:31.000Z","updated":"2020-12-17T10:05:14.481Z","comments":true,"path":"2020/10/19/my-new-post/","link":"","permalink":"https://hackertaco.github.io/2020/10/19/my-new-post/","excerpt":"","text":"마크다운으로 처음 글도 써보고, 뷰3도 투두리스트 구현까지 해본 초보 개발(희망)자.뷰로 관리자페이지를 만드는 그 날까지..! 열싐히 기록해볼 것이다. 1. vue3 tutorial을 찾다 유튭에 아무거나 때려 공부하기 2. vue 개략한 줄 요약 : 뷰는 적응하기 쉬워! 프레임워크 안에서 놀면 된다.뷰를 말해보자면 웹 페이지를 만드는 것을 도와주는!(리액트랑 비교해보자면, 리액트는 상대적으로 라이브러리의 성격이 강해서 js를 좀 잘해야 한다.) 뷰를 실행하는 가장 쉬운 방법은 cdn 사용 를 html head tag 안에 넣어주면 된다. 그러면 ! 3. 잡다한 지식 조각 뷰 3부터는 data가 함수의 모양을 하고 있어야 한다. vetur는 뷰 글자 자동완성 내지는 템플릿 자동완성 해주는 아주 조은 익스텐션 vue devtool로 많은 걸 할 수 있지. v-model은 data와 화면 둘다 묶는다. 4. directives 뷰에는 directives라는 지시어가 있다. 이는 template과 script를 서로 연결해주는 어떤것으로 우선 이해했다. data, computed, methods 등을 모두 연결할 수 있다. 그 중 한 예로 v-model은 input과 같이 html태그 중 어떤 것을 에력하는 태그인 경우에, vue script tag 내의 데이터와 입력 값을 서로 연결해준다. v-once는 렌더링이 딱 한번 되는 것. 5. vue router 라우터가 있어야 하는 이유는 vue가 SPA 즉, single page application 인 것과 관계가 있다. SPA는 최초 한번만 전체 페이지를 로딩한 후 데이터만 변경해서 사용하는 어플리케이션이다. 이 SPA는 html, js와 같은 파일을 렌더링할 때 클라이언트 사이드 렌더링이라는 방식을 이용한다. 기본적으로 페이지가 따로 없다 (single page니까!) 모든 페이지는 단순히 HTML5 History에 의해 렌더링 될 뿐이다. 그래서 언제 새 데이터를 불러와야 할지를 스스로 정해야 한다. 즉 사용자의 행동에 따라 어떤 데이터가 불려올지가 정해진다. SPA라고 할지라도 한 종류의 화면만 있는 것은 아니다 ! 화면에 따라 다른 주소를 가진다. 주소에 따라 여러 뷰를 렌더링하는 것을 라우팅이라고 하고, vue 자체에는 이 기능이 내장돼있지 않다. 대신 vue-router가 있다. 그러니까, 일단 vue-router를 add 해준다. 라우터를 통해 변할 페이지의 위치에서, 를 써줘 링크를 넣을 곳에 router-link 태그 main.js에 난 라우터를 쓸 것이라고 이야기해줘야한다. createApp(App).use(router) 이렇게? default mode는 hash mode이다. SPA 환경에서 바뀐 부분만 렌더링해주어야 하기에 hash(#)를 써서 full URL을 시뮬레이트하기 때문. 만일 이 해쉬를 없애고 싶다면, 라우터의 히스토리모드를 사용할 수 있다.","categories":[],"tags":[{"name":"개발뉴비","slug":"개발뉴비","permalink":"https://hackertaco.github.io/tags/%EA%B0%9C%EB%B0%9C%EB%89%B4%EB%B9%84/"}]}],"categories":[],"tags":[{"name":"스터디 자료구조","slug":"스터디-자료구조","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://hackertaco.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"스터디","slug":"스터디","permalink":"https://hackertaco.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"},{"name":"개발뉴비","slug":"개발뉴비","permalink":"https://hackertaco.github.io/tags/%EA%B0%9C%EB%B0%9C%EB%89%B4%EB%B9%84/"}]}