---
title: 자료구조 1. 배열, 연결 리스트
date: 2020-12-16 19:27:28
tags: 스터디
---

# 배열이란 ?

- 굉장히 흔히 사용되는 자료구조.
- 연관된 데이터를 하나의 변수에 그룹핑한 뒤 관리하기 위한 방법. -> 반복문과 연결시 효율적 정보 처리 가능.
- 데이터를 연속 저장하기 위해 내장된 형태로 제공한다. 그래서 heap이 아닌 stack에 쌓인다.

## 수학적 배열의 정의

- 1차원적인 묶음.
- [f(1),f(2),f(3),f(4),f(5),f(6)] == [3,1,-1,2,0,6]
- f(x)의 정의역(x)의 집합을 인덱스들(indices) 이라고 하며, 그 치역(f(x))의 집합을 Array라고 부른다.
- 치역과 인덱스를 합쳐서 엘리먼트라고 한다.

## js에서의 정의

- 정적인 언어들, 특히 C언어 같은 오래된 언어의 경우 컴파일 단계에서 Array의 크기, 형태, 값이 미리 정해져 있어야 한다.
- 그래서 array를 작은 크기로 선언하고 더 많은 값을 집어 넣으면 에러가 발생한다.
- 그러나 js에서는 객체 지향 언어 ! 객체로 제공한다.

```javascript
let arr = [];
arr[2] = 10;

let arr2 = new Array();
```

- 객체로 제공하기 때문에 Array를 선언만 하고, 값을 추가하는 방식을 사용한다.
- 타입도 상관없고, 상당히 유연쓰

- 이 배열을 이용해서 리스트를 구현해볼 수 있다.
- 배열을 기반으로 구현된 리스트를 순차 리스트라고 한다.
- 이 순차 리스트는 데이터를 나란히 저장하고, 중복된 데이터의 저장을 막지 않는다.

## 배열의 단점

- 배열은 인덱스를 이용해 편히 데이터 표현을 할 수 있다. 검색의 경우 시간 복잡도가 O(1)
- 그러나 중간에 빈 데이터, 즉 삭제와 같은 일이 발생했을 때, 데이터가 존재하지 않으므로 인덱스만 존재하고 나머지는 null로 처리가 돼버리는 문제
- 더불어 이를 정리하기 위해서 O(n)의 시간 복잡도가 생길 수 있는 문제가 있다.
- 그래서, 인덱스가 중요한 경우에는 배열을 사용하면 좋지만, 그게 아니라면 (추가나 삭제의 경우)그냥 연속적으로 (빈틈없이) 데이터가 위치하는 연결 리스트를 사용하는 것이 좋을 수 있다.

---

# 단일 연결 리스트 ?

## 목적과 이론

<img src="https://t1.daumcdn.net/cfile/tistory/996CEC465CFD723410"/>

- 위 사진과 같이, 단일 연결 리스트는 엘리먼트와 엘리먼트 간의 연결을 이용해 리스트를 구현한 것이다.
- 여기서 언급하는 엘리먼트는 배열의 엘리먼트와는 다르다. 배열의 엘리먼트는 인덱스와 데이터였다면, 연결 리스트에서는 노드 혹은 버텍스라는 개념으로 불리운다.
- 노드는 노드의 값과 다음 노드 즉, 포인터를 가지고 있어야 한다.
- 배열에 비해 추가나 삭제가 용이하다.
  <img src="https://dojang.io/pluginfile.php/709/mod_page/content/20/unit74-2.png"/>

- 만약 c 언어라면 위와 같이 노드를 구조체로 구현하고,
- java와 같은 객체지향 언어의 경우 객체에 데이터 필드와 링크 필드를 만들게 된다.
- 데이터 필드는 보통 value 라는 이름의 변수, 링크 필드는 next 변수를 사용한다.

### use case in CS

Implementation of stacks and queues
Implementation of graphs : Adjacency list representation of graphs is most popular which is uses linked list to store adjacent vertices.
Dynamic memory allocation : We use linked list of free blocks.
Maintaining directory of names
Performing arithmetic operations on long integers
Manipulation of polynomials by storing constants in the node of linked list
representing sparse matrices

- head?

* 첫번째 노드를 말한다. 이를 찾아야 다음의 데이터들도 연결지어 찾아낼 수 있다.

## 구현 로직

- java 언어를 사용

```java
public class SinglyLinkedList {
    Node head;

    class Node {
        int data;
        Node next;

        Node(int d) { data = d; }
    }
}
```

- 다이어그램과 연결지어 생각해 본다면, 각각의 네모는 노드, 제일 처음에 있는 노드는 헤드, 그곳에 적힌 숫자는 data, 다음을 가리키는 화살표는 next라고 할 수 있겠다.

- 여기서 다른 오퍼레이션, 예를 들면 insert나 remove를 구현해 본다면?

```java
 public void insert(int data) {
        Node newHead = new Node(data);
        if (head == null) {
            head = newHead;
            return;
        }
        newHead.next = head;
        head = newHead;
    }


```

- 이는 집어넣는 데이터가 head 자리에 올 때의 구현.

```java
 public void remove(int data) {
        Node preNode = head;
        Node tempNode = head.next;

        head = preNode.next;
        preNode.next = null;

    }


```

- 이는 삭제할 데이터가 head에 있을 때ㅡ

### 그 외에도 조회, 데이터 중간에서 삽입, 끝에 삽입, 중간 삭제 끝 삭제 등등이 있다.
